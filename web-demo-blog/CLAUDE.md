# CLAUDE.md — AI 코드 생성 변경 관리 가이드

## 프로젝트 개요

이 프로젝트는 AI 코드 생성 도구의 비결정성 문제를 방지하고, 스펙↔코드 간 형상 일관성을 유지하기 위한 규칙을 따릅니다.

---

## 핵심 원칙

### 1. 절대 재생성 금지 (No Regeneration)

- 이미 존재하는 코드를 **전체 재생성하지 마세요.**
- 스펙이 변경되면 기존 코드 위에서 **해당 부분만 증분 수정(incremental edit)**하세요.
- 파일을 새로 작성하는 것이 아니라, 기존 파일을 읽고 변경이 필요한 부분만 수정합니다.

### 2. 컨벤션 준수 (Convention First)

- 새 코드를 생성할 때는 반드시 기존 코드의 패턴을 따르세요.
- 동일 디렉토리 내 기존 파일을 먼저 확인하고, 그 구조·네이밍·패턴을 그대로 적용하세요.
- 아래 "코드 컨벤션" 섹션의 규칙을 우선 적용합니다.

### 3. 변경 추적성 (Traceability)

- **모든 작업은 `docs/requirements.md`에 등록된 요구사항 ID 기반으로 수행합니다.**
- 사용자의 지시가 요구사항 ID 없이 들어오면, AI가 먼저 `docs/requirements.md`에 요구사항을 등록한 뒤 작업을 시작합니다.
- 커밋 메시지 형식: `[REQ-XXXX] 변경 내용 요약`
- 코드 내 주요 변경 지점에 주석을 남기세요:

  ```
  // [REQ-XXXX] 요구사항 변경에 따른 수정 (2025-XX-XX)
  ```

#### 요구사항 등록 → 작업 수행 흐름

```
사용자 지시 입력
    │
    ▼
┌─────────────────────────────────┐
│ 1. 요구사항 ID가 명시되어 있는가?    │
└─────────┬───────────┬───────────┘
          │ Yes       │ No
          ▼           ▼
    ID 확인 후    docs/requirements.md에
    작업 진행     신규 등록 (ID 자동 부여)
          │           │
          ▼           ▼
┌─────────────────────────────────┐
│ 2. docs/requirements.md 상태 갱신  │
│    (등록 → 분석완료 → 진행중)       │
└─────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────┐
│ 3. 영향 범위 파악                  │
│    - 변경 대상 파일 목록 확인        │
│    - docs/requirements.md 영향 파일 갱신│
└─────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────┐
│ 4. 증분 수정 수행                  │
│    - 코드 주석에 REQ-XXXX 명시      │
│    - 한 번에 1개 파일/클래스 단위    │
└─────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────┐
│ 5. 작업 완료 후                   │
│    - docs/requirements.md 상태 → 완료│
│    - 커밋 메시지에 REQ-XXXX 포함   │
└─────────────────────────────────┘
```

### 4. 생성 범위 최소화 (Small Scope)

- 한 번에 하나의 함수 또는 하나의 클래스만 생성/수정하세요.
- 전체 모듈을 한 번에 만들지 마세요.
- 생성 후 반드시 기존 코드와의 일관성을 확인하세요.

### 5. 테스트 코드 필수 (Test Required)

- **모든 신규 코드 작성 시 대응하는 테스트 코드를 반드시 함께 작성하세요.**
- 기존 코드를 수정할 때는 **영향받는 기존 테스트를 함께 수정**하고, 필요시 새 테스트 케이스를 추가하세요.
- 테스트 없이 프로덕션 코드만 작성·커밋하는 것은 금지합니다.
- 테스트는 프로덕션 코드와 동일한 요구사항 ID(`REQ-XXXX`)로 추적합니다.

---

## 코드 컨벤션

> **아래 항목을 프로젝트에 맞게 수정하세요.**

### 언어 및 프레임워크

- 언어: [Java 25]
- 프레임워크: [Spring Boot 4.0.2]
- 웹 화면 템플릿: [Thymeleaf]
- 데이터베이스: [JPA, SLite3]
- 빌드 도구: [Gradle 9.3.1]

### 네이밍 규칙

- 클래스: PascalCase (예: `OrderService`)
- 메서드/함수: camelCase (예: `findOrderById`)
- 상수: UPPER_SNAKE_CASE (예: `MAX_RETRY_COUNT`)
- 파일명: 클래스명과 동일 또는 kebab-case

### 아키텍처 패턴

- 레이어 구조: Controller → Service (Interface + Impl) → Repository
- DTO와 Entity는 반드시 분리
- 예외 처리: 커스텀 예외 클래스(`BusinessException`) 사용
- 응답 형식: 공통 응답 래퍼(`ApiResponse<T>`) 사용

### 테스트 컨벤션

- 테스트 프레임워크: JUnit 5 + Spring Boot Test + Spring Security Test
- 테스트 클래스 네이밍: `{대상클래스명}Test` (예: `PostServiceImplTest`, `PostControllerTest`)
- 테스트 메서드 네이밍: `{메서드명}_{시나리오}_{기대결과}` (예: `findById_존재하는ID_정상반환`)
- 레이어별 테스트 전략:
  - **Service 계층**: `@ExtendWith(MockitoExtension.class)` 단위 테스트, Repository를 Mock 처리
  - **Controller 계층**: `@WebMvcTest` 슬라이스 테스트, Service를 Mock 처리
  - **Repository 계층**: `@DataJpaTest` 슬라이스 테스트, 실제 DB(H2) 사용
  - **통합 테스트**: `@SpringBootTest` 필요 시에만 사용 (전체 컨텍스트 로딩)
- 테스트 데이터: 각 테스트 메서드 내에서 `@BeforeEach` 또는 직접 생성, 테스트 간 독립성 보장
- Assertion: AssertJ (`assertThat`) 사용 권장

### 디렉토리 구조

```
src/
├── main/
│   └── java/com/demo/blog/
│       ├── controller/     # REST API 엔드포인트
│       ├── service/        # 비즈니스 로직 (인터페이스)
│       │   └── impl/       # 서비스 구현체
│       ├── repository/     # 데이터 접근 계층
│       ├── domain/         # Entity, VO
│       ├── dto/            # 요청/응답 DTO
│       ├── config/         # 설정 클래스
│       ├── exception/      # 커스텀 예외
│       └── common/         # 공통 유틸리티
└── test/
    └── java/com/demo/blog/
        ├── controller/     # Controller 슬라이스 테스트
        ├── service/        # Service 단위 테스트
        │   └── impl/       # ServiceImpl 단위 테스트
        ├── repository/     # Repository 슬라이스 테스트
        └── integration/    # 통합 테스트 (필요 시)
```

---

## 변경 작업 시 워크플로우

### 사용자 지시 수신 시 (최우선 수행)

1. **요구사항 등록 확인**: 사용자의 지시에 REQ-ID가 있는지 확인
2. **ID 없으면 자동 등록**: `docs/requirements.md`에 적절한 구분(F/N/B/R)으로 신규 등록
3. **등록 내용 사용자에게 고지**: "REQ-F002로 등록했습니다. 작업을 진행합니다." 형태로 안내
4. **이후 아래 워크플로우 진행**

### 스펙 변경이 발생했을 때

1. **영향 범위 파악**: 변경되는 스펙이 어떤 파일들에 영향을 주는지 먼저 확인 **(테스트 파일 포함)**
2. **기존 코드 확인**: 해당 파일들을 읽어서 현재 구현 상태 파악
3. **증분 수정 수행**: 변경이 필요한 부분만 정확히 수정
4. **테스트 코드 수정**: 변경된 프로덕션 코드에 대응하는 테스트를 함께 수정하고, 새로운 분기/로직이 추가되면 테스트 케이스도 추가
5. **테스트 실행·검증**: `./gradlew test` 실행하여 전체 테스트 통과 확인
6. **시나리오 문서 갱신**: 웹 컨트롤러·DTO·Service·SecurityConfig 변경 시 `docs/test-scenarios.md` 해당 시나리오 갱신 (→ "사용자 테스트 시나리오 문서 자동 생성" 섹션 참조)
7. **일관성 검증**: 수정 후 관련 파일들과의 일관성 확인
8. **변경 이력 기록**: 커밋 메시지에 스펙 ID 포함, `docs/requirements.md` 상태 갱신

### 신규 기능 개발 시

1. **레퍼런스 확인**: 동일 레이어의 기존 파일을 먼저 확인 **(기존 테스트 파일 패턴도 확인)**
2. **패턴 복제**: 기존 파일의 구조를 그대로 따라서 생성
3. **단위별 생성**: 한 번에 하나의 파일/클래스만 생성
4. **테스트 코드 작성**: 생성한 프로덕션 코드에 대응하는 테스트 클래스를 동일 요구사항 ID로 작성
   - Service 구현체 → 단위 테스트 (Mock 기반)
   - Controller → 슬라이스 테스트 (`@WebMvcTest`)
   - Repository → 슬라이스 테스트 (`@DataJpaTest`, 필요 시)
5. **테스트 실행·검증**: `./gradlew test` 실행하여 전체 테스트 통과 확인
6. **시나리오 문서 작성**: 웹 컨트롤러·DTO·Service·SecurityConfig 신규 추가 시 `docs/test-scenarios.md`에 대응 시나리오 추가 (→ "사용자 테스트 시나리오 문서 자동 생성" 섹션 참조)
7. **통합 확인**: 생성 후 호출하는 쪽과 호출받는 쪽의 인터페이스 일치 확인
8. **요구사항 완료 처리**: `docs/requirements.md` 상태를 `완료`로 갱신

---

## 사용자 테스트 시나리오 문서 자동 생성

### 개요

코드베이스를 분석하여 **사용자 관점의 E2E 테스트 시나리오 문서**를 `docs/test-scenarios.md`에 작성·갱신합니다. 웹 컨트롤러, DTO 검증 규칙, Service 비즈니스 로직, SecurityConfig를 체계적으로 분석하여 완전한 시나리오 세트를 도출합니다.

### 분석 대상 소스

| 소스 | 추출 대상 | 분석 파일 패턴 |
| ------ | ---------- | --------------- |
| 웹 컨트롤러 (`controller/web/`) | 사용자 동작(Action) 흐름 | `*WebController.java` |
| DTO 검증 규칙 (`dto/`) | 입력 유효성 시나리오 | `*RequestDto.java` (`@NotBlank`, `@Size`, `@Email` 등) |
| Service 비즈니스 로직 (`service/impl/`) | 예외/에러 시나리오 | `*ServiceImpl.java` (`BusinessException` throw 지점) |
| SecurityConfig (`config/`) | 보안/인증 시나리오 | `SecurityConfig.java` (`permitAll`, `authenticated`, `formLogin`, `logout`) |

### 시나리오 분류 체계

- **TC-AUTH**: 인증 (회원가입, 로그인, 로그아웃)
- **TC-POST**: 포스트 관리 (CRUD)
- **TC-CMT**: 댓글 관리 (생성, 삭제)
- **TC-SEC**: 권한/보안
- **TC-VAL**: 입력 유효성 검증

### 각 시나리오 필수 포함 항목

```
#### TC-XXX-NNN: {시나리오 제목}

- **카테고리**: 정상 경로 | 예외 경로 | 보안 | 유효성 검증
- **사전 조건**: {테스트 전 필요한 상태}
- **테스트 단계**:
  1. {Step-by-step 사용자 동작}
- **기대 결과**:
  - {예상되는 시스템 응답}
- **코드 근거**: `{파일명}:{라인번호}` (변경 추적용)
```

### 시나리오 도출 워크플로우

1. **웹 컨트롤러 분석**: `controller/web/` 하위의 모든 `@GetMapping`, `@PostMapping` 핸들러를 순회하여 정상 경로 시나리오 도출
2. **DTO 검증 규칙 분석**: `dto/` 하위의 모든 `@NotBlank`, `@Size`, `@Email`, `@NotNull` 등 Bean Validation 어노테이션을 순회하여 유효성 검증 시나리오 도출
3. **Service 비즈니스 로직 분석**: `service/impl/` 하위의 모든 `BusinessException` throw 지점을 순회하여 예외 경로 시나리오 도출
4. **SecurityConfig 분석**: `permitAll()`, `authenticated()`, `formLogin()`, `logout()` 설정을 분석하여 보안 시나리오 도출
5. **시나리오 통계 작성**: 카테고리별 시나리오 수를 집계하여 문서 말미에 통계표 작성
6. **코드 소스별 매핑표 작성**: 소스 파일:라인 → 시나리오 ID 양방향 추적 매핑표 작성

### 검증 기준

- **엔드포인트 커버리지**: 모든 웹 엔드포인트(`@GetMapping`, `@PostMapping`)가 최소 1개 시나리오로 커버되는지 확인
- **예외 커버리지**: 모든 `BusinessException` 메시지가 예외 시나리오로 반영되었는지 확인
- **유효성 커버리지**: 모든 DTO 검증 규칙(`@NotBlank`, `@Size`, `@Email` 등)이 유효성 시나리오로 반영되었는지 확인
- **보안 커버리지**: SecurityConfig의 모든 접근 제어 규칙이 보안 시나리오로 반영되었는지 확인

### 변경 추적성 (양방향 추적)

- **코드 → 시나리오**: 각 시나리오의 "코드 근거" 필드에 `파일명:라인번호`를 명시하여, 코드 변경 시 영향받는 시나리오를 즉시 식별
- **시나리오 → 코드**: 문서 말미에 "코드 소스별 시나리오 매핑" 표를 작성하여, 특정 파일 변경 시 갱신이 필요한 시나리오 목록을 역추적

### 시나리오 문서 갱신 트리거

아래 파일이 변경될 때 `docs/test-scenarios.md`도 함께 갱신해야 합니다:

- `controller/web/*WebController.java` — 엔드포인트 추가/변경/삭제 시
- `dto/*RequestDto.java` — 검증 규칙 추가/변경/삭제 시
- `service/impl/*ServiceImpl.java` — BusinessException throw 지점 추가/변경/삭제 시
- `config/SecurityConfig.java` — 접근 제어 규칙 변경 시

---

## 금지 사항

- ❌ 기존 파일을 삭제하고 새로 작성하는 행위
- ❌ 동일 기능을 완전히 다른 방식으로 재구현하는 행위
- ❌ 프로젝트 컨벤션에 없는 새로운 패턴을 임의로 도입하는 행위
- ❌ 한 번의 작업에서 3개 이상의 파일을 동시에 대규모 변경하는 행위
- ❌ **요구사항 ID 없이 코드를 변경하는 행위 (docs/requirements.md 미등록 상태에서 작업 금지)**
- ❌ 요구사항 상태를 갱신하지 않고 작업을 종료하는 행위
- ❌ **테스트 코드 없이 프로덕션 코드만 작성·커밋하는 행위**
- ❌ 테스트가 실패하는 상태에서 작업을 완료 처리하는 행위
- ❌ **웹 컨트롤러·DTO·Service·SecurityConfig 변경 시 `docs/test-scenarios.md`를 갱신하지 않는 행위**

---

## 역방향 산출물 생성 (리버스 엔지니어링)

감리 또는 고객 산출물 제출이 필요한 경우, 최종 코드를 기반으로 설계서를 재생성할 수 있습니다.

요청 예시:

```
이 코드를 기반으로 상세설계서를 작성해줘.
- 클래스 다이어그램
- 시퀀스 다이어그램
- 인터페이스 명세
- 비즈니스 로직 설명
형식은 [프로젝트 산출물 템플릿]을 따라줘.
```

---

## 참고: 이 파일의 사용법

이 `CLAUDE.md` 파일을 프로젝트 루트에 위치시키면 Claude Code가 자동으로 읽어서 위 규칙을 따릅니다. `docs/requirements.md`에 요구사항을 관리하여 추적이 가능합니다. 프로젝트 특성에 맞게 "코드 컨벤션" 섹션을 반드시 커스터마이징하세요.
